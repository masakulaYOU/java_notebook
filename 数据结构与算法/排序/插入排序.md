# 插入排序

通常人们整理壳牌的方法是一张一张的来，将每一张牌插入到其他已经有序的牌中的适当位置。在计算机的实现中，为了要给插入的元素腾出空间，我们需要将其余所有元素在插入之前都向右移动一位。这种算法叫做插入排序。

与选择排序一样，当前索引左边的元素都是有序的，但它们的最终位置还不确定，为了给更小的元素腾出空间，它们可能会被移动。但是当索引到达数组的右端时，数组排序就完成了。

和选择排序不同的是，插入排序所需的时间取决于输入中元素的初始顺序。

> 对于随机排列的长度为$N$且主键不重复的数组，平均情况下插入排序需要$\sim N^2/4$次比较以及$\sim N^2/4$次交换。最坏情况下需要$\sim N^2/2$次比较和$\sim N^2/2$次交换，最好情况下需要$N-1$次比较和$0$次交换。

```java
public class Insertion {
    public static void sort(Comparable[] a) {
        // 将a[]按升序排列
        int N = a.length;
        for(int i = 1; i < N; i++) {
            // 将a[i]插入到a[i-1],a[i-2],...之中
            for(int j = i; j > 0 && less(a[j], a[j - 1]); j--) {
                exchange(a, j, j - 1);
            }
        }
    }
}
```

> 部分有序：如果数组中倒置的数量小于数组大小的某个倍数，那么我们说这个数组是部分有序的。有几种典型的部分有序的数组：
>
> - 数组中每个元素距离它的最终位置都不远
> - 一个有序的大数组接一个小数组
> - 数组中只有几个元素的位置不正确
>
> 插入排序对这样的数组很有效，选择排序则不然。
>
> 插入排序需要交换操作和数组中倒置的数量相同，需要的比较次数大于等于倒置的数量，小于等于倒置的数量加上数组的大小再减一。

